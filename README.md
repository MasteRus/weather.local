**Тестовое задание для Backend разработчика**:
Реализовать микросервис по агрегации данных из свободных источников прогноза погоды (2-3 достаточно) для неограничиваемого количества локаций. 
Сбор данных осуществляется фоновой джобой. RESTful API (без авторизации) даёт возможность:
- добавить локацию
- вывести средний результат по указанной локации за указанный период (использовать кэш)

**Стэк**:
PHP 8+ (Laravel, Lumen), MySQL, Docker?, Kafka?

На выходе:
- пошаговая блоксхема работы приложения
- простая интеграция дополнительных источников (см. раздел [DataSource](DOCUMENTATION/DataSource.md)) DONE
- схема структуры и связей базы данных DONE
- кодовая база удовлетворяет принципам SOLID DONE
- применение транзакций БД в коде (не требуется)
- логирование (info + error) разделеное по разным потокам
- успешные & неуспешные функциональные и юнит тесты (там где это необходимо) DONE
- описание как запустить приложение DONE

Необходимый процент прогресса для анализа 60+

Результат в github || gitlab

# Примечания к выполненному заданию
Задание имеет 2 способа запуска (нативно и докер). 
В ходе выполнения упор делался на заменяемость, тестируемость, документируемость и правильность работы.
Приложение представляет собой REST-Api resource crud и консольную джобу для достижения асинхронности

**Основные моменты**

Изначально я задавал вопрос по тестовому заданию, делать ли на основе исторических данных или данных по прогнозу, 
однако, ответа мне не последовало, поэтому сделал на основе исторических данных. Наибольшая трудность была найти бесплатные источники данных, которые не имеют слишком жестких лимитов. 

В проекте 2 источника данных:
open-meteo и weather-api.com. Второй требует регистрации (https://www.weatherapi.com/pricing.aspx), есть бесплатный аккаунт, но на бесплатном работает только по территории США. 
В конфигах (/config/weather-datasources) есть источника данных есть пример, как мы включать или выключать данные источники, а также маппинг настроек.

В папке documentation есть ER-диаграмма и коллекция для постмана с 2 вариантами окружения (нативно и через докер), также доступен сваггер по пути /api/documentation
Есть [краткая инструкция](./DOCUMENTATION/DataSource.md) по подключению нового источника: 

Для добавления нового источника требуется реализовать 2 класса - парсер и источник, 2 джобы для асинхронности, а также файл конфига с урлом и настройками парсинга.

# Что ещё можно сделать лучше:

0. В источниках почему-то данные могут появляться не сразу, поэтому я не настраивал шедуллер, т.к. этот вопрос требует прояснения.
1. Прикрутить Redis и Horizon для очередей
2. Поработать над обработкой ошибок от источника (на случай смены формата)
3. Диаграмма последовательности в документации
4. Кэширование (здесь нагрузки небольшие, однако в будущем это может быть)

# Установка
**Инструкция по установке для работы локально**:

1. Склонируйте репозиторий, войдите в папку проекта, установите зависимости, создайте бд mysql c юзером, создайте .env файл путем копирования и редактирования, запустите генерацию ключа, накатите миграции на бд
```
cd weather-local
composer install
cp .env.example .env
php artisan key:generate
php artisan migrate
```

2. Для запуска тестов воспользуйтесь командой

```
php artisan test
```

3. Запустите очередь через консоль

```
php artisan queue:work --tries=3
```

4. Для получения данных можно воспользоваться командой
```
php artisan app:weather-data-get {start_date} {finish_date}
```

где {start_date} {finish_date} - это дата в формате Y-m-d

**Инструкция для работы через докер**:

1. Склонируйте репозиторий, войдите в папку проекта, установите зависимости, создайте .env файл путем копирования и запустите генерацию ключа

```
cd weather-local
docker-compose up -d
docker-compose exec app composer install
cp .env.example .env
docker-compose exec app php artisan key:generate
docker-compose exec app php artisan migrate
```

**Примечание: иногда бд стартует медленнее, чем ожидается, поэтому миграция может не проходить из-за проблемы с подключением к БД. Просто подождите пару минут и повторите миграцию**

2. Для запуска тестов воспользуйтесь командой

```
docker-compose exec app php artisan test
```

3. Для получения данных можно воспользоваться командой
```
docker-compose exec app php artisan app:weather-data-get {start_date} {finish_date}
```

где {start_date} {finish_date} - это дата в формате Y-m-d





