**Тестовое задание для Backend разработчика**:
Реализовать микросервис по агрегации данных из свободных источников прогноза погоды (2-3 достаточно) для неограничиваемого количества локаций. Сбор данных осуществляется фоновой джобой. RESTful API (без авторизации) даёт возможность:
- добавить локацию
- вывести средний результат по указанной локации за указанный период (использовать кэш)

**Стэк**:
PHP 8+ (Laravel, Lumen), MySQL, Docker?, Kafka?

На выходе:
- пошаговая блоксхема работы приложения
- простая интеграция дополнительных источников
- схема структуры и связей базы данных
- кодовая база удовлетворяет принципам SOLID
- применение транзакций БД в коде
- логирование (info + error) разделеное по разным потокам
- успешные & неуспешные функциональные и юнит тесты (там где это необходимо)
- описание как запустить приложение

Необходимый процент прогресса для анализа 60+

Результат в github || gitlab

# Примечания к выполненному заданию
Задание имеет 2 способа запуска (нативно и докер). 
В ходе выполнения упор делался на заменяемость, тестируемость, документируемость и правильность работы.
Приложение представляет собой REST-Api resource crud для достижения.

**Основные моменты**

Изначально я задавал вопрос по тестовому заданию, делать ли на основе исторических данных или данных по прогнозу, 
однако, ответа мне не последовало, поэтому сделал на основе исторических данных. Наибольшая трудность была найти бесплатные источники данных, которые не имеют слишком жестких лимитов. 

В проекте 2 источника данных:
open-meteo и weather-api.com. Второй требует регистрации (https://www.weatherapi.com/pricing.aspx), поэтому так просто вы его не проверите. 
В конфигах (/config/weather-datasources) есть источника данных есть пример, как мы включать или выключать данные источники, а также маппинг настроек.

В папке documentation есть ER-диаграмма и коллекция для постмана с 2 вариантами окружения (нативно и через докер), 

Для добавления нового источника требуется реализовать 2 класса - парсер и источник, 2 джобы для асинхронности, а также файл конфига с урлом и настройками парсинга.
В целом, не считаю что решение удачное, можно сократить кол-во джоб, плюс покопать с EventListener.
Также есть вариант с использованием абстрактной фабрики для порождения всего семейства, но я не уверен, что при добавлении источников общий контракт не измениться.

# Что ещё можно сделать лучше:

0. В источниках почему-то данные могут появляться не сразу, поэтому я не настраивал шедуллер, т.к. этот вопрос требует прояснения.
1. Прикрутить Redis и Horizon для очередей
2. Поработать над обработкой ошибок от источника (на случай смены формата)
3. Диаграмма последовательности в документации
4. Кэширование (здесь нагрузки не большие, однако в будущем это может быть)
5. Swagger вместо коллекции

# Установка
**Инструкция по установке для работы локально**:

1. Склонируйте репозиторий, войдите в папку проекта, установите зависимости, создайте бд mysql c юзером, создайте .env файл путем копирования и редактирования, запустите генерацию ключа, накатите миграции на бд
```
cd weather-local
composer install
cp .env.example .env
php artisan key:generate
php artisan migrate
```

2. Для запуска тестов воспользуйтесь командой

```
php artisan test
```

3. Запустите очередь через консоль

```
php artisan queue:work --tries=3
```

4. Для получения данных можно воспользоваться командой
```
php artisan app:weather-data-get {start_date} {finish_date}
```

где {start_date} {finish_date} - это дата в формате Y-m-d

**Инструкция для работы через докер**:

1. Склонируйте репозиторий, войдите в папку проекта, установите зависимости, создайте .env файл путем копирования и запустите генерацию ключа

```
cd weather-local
docker-compose up -d
docker-compose exec app composer install
cp .env.example .env
docker-compose exec app php artisan key:generate
docker-compose exec app php artisan migrate
```

**Примечание: иногда бд стартует медленнее, чем ожидается, поэтому миграция может не проходить из-за проблемы с подключением к БД. Просто подождите пару минут и повторите миграцию**

2. Для запуска тестов воспользуйтесь командой

```
docker-compose exec app php artisan test
```

3. Для получения данных можно воспользоваться командой
```
docker-compose exec app php artisan app:weather-data-get {start_date} {finish_date}
```

где {start_date} {finish_date} - это дата в формате Y-m-d



